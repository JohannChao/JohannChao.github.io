<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>It&#39;s Johann</title>
  
  <subtitle>Complain less Think more</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yhzhao.com/"/>
  <updated>2019-10-21T16:55:22.891Z</updated>
  <id>https://www.yhzhao.com/</id>
  
  <author>
    <name>Johann</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA中常见问题</title>
    <link href="https://www.yhzhao.com/IDE/IDEA%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://www.yhzhao.com/IDE/IDEA中常见问题/</id>
    <published>2019-10-11T01:59:37.000Z</published>
    <updated>2019-10-21T16:55:22.891Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 IDEA 的过程中，遇到的一些问题，在此做一个总结，这些问题不都是IDE的，也有java的。</p><a id="more"></a><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>Cannot start compilation: the output path is not specified for module</p><p>在新建的类中，运行main方法，报错：</p><img src="/IDE/IDEA中常见问题/11.png" title="图1.1"><p><strong>原因：</strong><br>这是由于没有设置Project的output路径导致的</p><img src="/IDE/IDEA中常见问题/12.png" title="图1.2"><p><strong>解决：</strong><br>打开File—Project Structure</p><img src="/IDE/IDEA中常见问题/13.png" title="图1.3"><p>在 output 下的空白框中，设置outPut路径，选择自己的Project，在路径后面拼接上\out即可。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>java.lang.SecurityException: Prohibited package name: java.com.xxxx</p><img src="/IDE/IDEA中常见问题/21.png" title="图2.1"><p><strong>原因：</strong></p><p>根据异常首要信息得知，是由于包名不合法所致。</p><p>点击报异常的位置，在ClassLoader包下的源码中，发现这段逻辑代码</p><img src="/IDE/IDEA中常见问题/22.png" title="图2.2"><p>加载过程中，如果传入的类的包名是 null 或是以 “java.” 开头，就会报出该异常。</p><p><strong>解决：</strong></p><p>修改包名即可。</p><p>在IDEA中，由于自己选择以 main 为源码包</p><img src="/IDE/IDEA中常见问题/23.png" title="图2.3"><img src="/IDE/IDEA中常见问题/24.png" title="图2.4"><p>现修改使用默认的 src 为源码包</p><img src="/IDE/IDEA中常见问题/25.png" title="图2.5"><img src="/IDE/IDEA中常见问题/26.png" title="图2.6"><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>Error:java: 无效的源发行版: 11</p><img src="/IDE/IDEA中常见问题/31.png" title="图3.1"><p><strong>原因：</strong></p><p>使用的java版本不一致</p><p><strong>解决：</strong></p><p>可以修改Project中的 language level</p><img src="/IDE/IDEA中常见问题/32.png" title="图3.2"><p>或者修改Module中的 language level</p><img src="/IDE/IDEA中常见问题/33.png" title="图3.3">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 IDEA 的过程中，遇到的一些问题，在此做一个总结，这些问题不都是IDE的，也有java的。&lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="https://www.yhzhao.com/categories/IDE/"/>
    
    
      <category term="java" scheme="https://www.yhzhao.com/tags/java/"/>
    
      <category term="IDE" scheme="https://www.yhzhao.com/tags/IDE/"/>
    
      <category term="BUG" scheme="https://www.yhzhao.com/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>在Intellij IDEA中使用Debug</title>
    <link href="https://www.yhzhao.com/IDE/%E5%9C%A8Intellij-IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug/"/>
    <id>https://www.yhzhao.com/IDE/在Intellij-IDEA中使用Debug/</id>
    <published>2019-10-09T03:34:42.000Z</published>
    <updated>2019-10-10T06:52:15.233Z</updated>
    
    <content type="html"><![CDATA[<blockquote><footer><strong>原文来源： bojiangzhou</strong><cite><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html" target="_blank" rel="noopener">在Intellij IDEA中使用Debug</a></cite></footer></blockquote> <br><p>Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。</p><a id="more"></a><p>所以学习下如何在Intellij IDEA中使用好Debug，主要包括如下内容：</p><p>　　　　一、Debug开篇</p><p>　　　　二、基本用法&amp;快捷键</p><p>　　　　三、变量查看</p><p>　　　　四、计算表达式</p><p>　　　　五、智能步入</p><p>　　　　六、断点条件设置</p><p>　　　　七、多线程调试</p><p>　　　　八、回退断点</p><p>　　　　九、中断Debug</p><p>　　　　十、附：JRebel激活</p><hr><h3 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a>一、Debug开篇</h3><p>首先看下IDEA中Debug模式下的界面。</p><p>　　如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：</p><p>　　① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</p><p>　　② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。</p><p>　　③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。</p><p>　　④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。</p><p>　　⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。</p><p>　　⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</p><p>　　⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。</p><p>　　⑧ Watches：查看变量，可以将Variables区中的变量拖到Watches中查看。</p><p>[图1.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/11.png" title="图1.1"><p>[图1.2]：在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口</p><img src="/IDE/在Intellij-IDEA中使用Debug/12.png" title="图1.2"><p>[图1.3]：如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。</p><img src="/IDE/在Intellij-IDEA中使用Debug/13.png" title="图1.3"><p>[图1.4]：在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。</p><img src="/IDE/在Intellij-IDEA中使用Debug/14.png" title="图1.4"><h3 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a>二、基本用法&amp;快捷键</h3><p>Debug调试的功能主要对应着图一中4和5两组按钮：</p><p>1、首先说第一组按钮，共8个按钮，从左到右依次如下：</p><p>[图2.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/21.png" title="图2.1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</span><br><span class="line"></span><br><span class="line">&gt; Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</span><br><span class="line"></span><br><span class="line">&gt; Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</span><br><span class="line"></span><br><span class="line">&gt; Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</span><br><span class="line"></span><br><span class="line">&gt; Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</span><br><span class="line"></span><br><span class="line">&gt; Drop Frame (默认无)：回退断点，后面章节详细说明。</span><br><span class="line"></span><br><span class="line">&gt; Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</span><br><span class="line"></span><br><span class="line">&gt; Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。</span><br></pre></td></tr></table></figure><p>2、第二组按钮，共7个按钮，从上到下依次如下：</p><p>[图2.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/22.png" title="图2.2">  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; Rerun &apos;xxxx&apos;：重新运行程序，会关闭服务后重新启动程序。</span><br><span class="line"></span><br><span class="line">&gt; Update &apos;tech&apos; application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。</span><br><span class="line"></span><br><span class="line">&gt; Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</span><br><span class="line"></span><br><span class="line">&gt; Pause Program：暂停程序，启用Debug。目前没发现具体用法。</span><br><span class="line"></span><br><span class="line">&gt; Stop &apos;xxx&apos; (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</span><br><span class="line"></span><br><span class="line">&gt; View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。</span><br><span class="line"></span><br><span class="line">&gt; Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。</span><br></pre></td></tr></table></figure><p>[图2.3]：更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。</p><p>一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。</p><p>下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。</p><img src="/IDE/在Intellij-IDEA中使用Debug/23.png" title="图2.3"> <p>[图2.4]</p><img src="/IDE/在Intellij-IDEA中使用Debug/24.png" title="图2.4"> <h3 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a>三、变量查看</h3><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。</p><p>1、如下，在IDEA中，参数所在行后面会显示当前变量的值。</p><p>[图3.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/31.png" title="图3.1"> <p>2、光标悬停到参数上，显示当前变量信息。点击打开详情如图3.3。我一般会使用这种方式，快捷方便。</p><p>[图3.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/32.png" title="图3.2"> <p>[图3.3]</p><img src="/IDE/在Intellij-IDEA中使用Debug/33.png" title="图3.3"> <p>3、在Variables里查看，这里显示当前方法里的所有变量。</p><p>[图3.4]</p><img src="/IDE/在Intellij-IDEA中使用Debug/34.png" title="图3.4"> <p>4、在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。</p><p>[图3.5]</p><img src="/IDE/在Intellij-IDEA中使用Debug/35.png" title="图3.5"> <p>如果你发现你没有Watches，可能在下图所在的地方。</p><p>[图3.6]</p><img src="/IDE/在Intellij-IDEA中使用Debug/36.png" title="图3.6"> <p>[图3.7]</p><img src="/IDE/在Intellij-IDEA中使用Debug/37.png" title="图3.7"> <h3 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a>四、计算表达式</h3><p>在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p><p>[图4.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/41.png" title="图4.1"> <p>1、按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。</p><p>这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。</p><p>[图4.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/42.png" title="图4.2"> <p>2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了不是。</p><p>[图4.3]</p><img src="/IDE/在Intellij-IDEA中使用Debug/43.png" title="图4.3"> <h3 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a>五、智能步入</h3><p>想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。</p><p>那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1</p><p>[图5.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/51.png" title="图5.1"> <p>按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法，如图5.2，点击方法进入方法内部。</p><p>如果只有一个方法，则直接进入，类似Force Step Into。</p><p>[图5.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/52.png" title="图5.2"> <h3 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a>六、断点条件设置</h3><p>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p><p>1、在断点上右键直接设置当前断点的条件，如图6.1，我设置exist为true时断点才生效。</p><p>[图6.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/61.png" title="图6.1"> <p>2、点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</p><p>Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</p><p>勾选Log message to console，则会将当前断点行输出到控制台，如图6.3</p><p>勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。</p><p>[图6.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/62.png" title="图6.2"> <p>[图6.3]</p><img src="/IDE/在Intellij-IDEA中使用Debug/63.png" title="图6.3"> <p>3、再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。</p><p>Instance filters：实例过滤，输入实例ID(如图6.5中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。</p><p>Class filters：类过滤，根据类名过滤，同样没有成功….</p><p>Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p><p>[图6.4]</p><img src="/IDE/在Intellij-IDEA中使用Debug/64.png" title="图6.4"> <p>[图6.5]</p><img src="/IDE/在Intellij-IDEA中使用Debug/65.png" title="图6.5"> <p>4、异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p>如图6.6，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。</p><p>我这里添加了一个NullPointerException异常断点，如图6.8，出现空指针异常后，自动定位在空指针异常行。</p><p>[图6.6]</p><img src="/IDE/在Intellij-IDEA中使用Debug/66.png" title="图6.6"> <p>[图6.7]</p><img src="/IDE/在Intellij-IDEA中使用Debug/67.png" title="图6.7"> <p>[图6.8]</p><img src="/IDE/在Intellij-IDEA中使用Debug/68.png" title="图6.8"> <h3 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a>七、多线程调试</h3><p>一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p><p>那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图7.1，然后点击Make Default设置为默认选项。</p><p>[图7.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/71.png" title="图7.1"> <p>切换线程，在图7.2中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。</p><p>[图7.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/72.png" title="图7.2"> <h3 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a>八、回退断点</h3><p>在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p><p>1、首先认识下这个方法调用栈，如图8.1，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p><p>[图8.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/81.png" title="图8.1"> <p>2、断点回退</p><p>所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p><p>回退的方式有两种，一种是Drop Frame按钮(图8.2)，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，如图8.3)。</p><p>第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame(图8.4)，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。</p><p>但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</p><p>图[8.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/82.png" title="图8.2"> <p>图[8.3]</p><img src="/IDE/在Intellij-IDEA中使用Debug/83.png" title="图8.3"> <p>图[8.4]</p><img src="/IDE/在Intellij-IDEA中使用Debug/84.png" title="图8.4"> <h3 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a>九、中断Debug</h3><p>想要在Debug的时候，中断请求，不要再走剩余的流程了？</p><p>有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p><p>确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程，如图9.1。</p><p>点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p><p>[图9.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/91.png" title="图9.1"> <p>[图9.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/92.png" title="图9.2"> <h3 id="十、附：JRebel激活"><a href="#十、附：JRebel激活" class="headerlink" title="十、附：JRebel激活"></a>十、附：JRebel激活</h3><p>在原文章中，无法再使用的 “<a href="https://my.jrebel.com/&quot;" target="_blank" rel="noopener">https://my.jrebel.com/&quot;</a> 地址登录激活了，现在附上新的激活办法。</p><p>1，首先在IDE中安装 JRebel for IntelliJ 插件。</p><p>[图10.1]</p><img src="/IDE/在Intellij-IDEA中使用Debug/101.png" title="图10.1"> <p>2，安装完成后，是未激活的，需要我们手动激活。</p><p>在<a href="https://pan.baidu.com/s/1hq6yUQV56lSW8-OQ_xMp5g" target="_blank" rel="noopener">此地址</a>下载激活插件，提取码[j7tc]。下载完成后，双击打开该插件，不要关闭窗口。</p><p>3，打开IDE中的JRebel插件，打开激活窗口，如图10.2</p><p>[图10.2]</p><img src="/IDE/在Intellij-IDEA中使用Debug/102.png" title="图10.2"> <p>首行输入 <a href="http://127.0.0.1:8888/自定义的GUID码" target="_blank" rel="noopener">http://127.0.0.1:8888/自定义的GUID码</a></p><p>按照以下<a href="http://www.ofmonkey.com/transfer/guid" target="_blank" rel="noopener">地址</a>生成自定义的GUID码，并替换拼接到<a href="http://127.0.0.1:8888/之后。" target="_blank" rel="noopener">http://127.0.0.1:8888/之后。</a></p><p>次一行输入自己的邮箱，勾选aggre，点击右下角按钮激活。</p><p>4，激活完成后，关闭激活插件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;原文来源： bojiangzhou&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/idea-debug.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在Intellij IDEA中使用Debug&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; 
&lt;br&gt;

&lt;p&gt;Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。&lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="https://www.yhzhao.com/categories/IDE/"/>
    
    
      <category term="IDE" scheme="https://www.yhzhao.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Oracle中的Pivot函数</title>
    <link href="https://www.yhzhao.com/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/Oracle%E4%B8%AD%E7%9A%84Pivot%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yhzhao.com/数据库/oracle/Oracle中的Pivot函数/</id>
    <published>2019-09-20T07:15:41.000Z</published>
    <updated>2019-10-10T06:52:04.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pivot函数"><a href="#Pivot函数" class="headerlink" title="Pivot函数"></a>Pivot函数</h3><p>Pivot函数是在Oracle 数据库 11g 推出之后，新增的一个行数据转列数据的函数。</p><a id="more"></a><p>基础数据展示：</p><table><thead><tr><th>id</th><th>name</th><th>province_code</th><th>visit_times</th></tr></thead><tbody><tr><td>1</td><td>ZhangZi</td><td>BJ</td><td>0</td></tr><tr><td>1</td><td>LiZhen</td><td>BJ</td><td>0</td></tr><tr><td>1</td><td>LiuHong</td><td>BJ</td><td>1</td></tr><tr><td>1</td><td>WangChao</td><td>SH</td><td>0</td></tr><tr><td>1</td><td>QinNing</td><td>SH</td><td>1</td></tr><tr><td>1</td><td>ZhaoYun</td><td>SH</td><td>2</td></tr><tr><td>1</td><td>HongShen</td><td>SH</td><td>2</td></tr><tr><td>1</td><td>MiFeng</td><td>HEB</td><td>0</td></tr><tr><td>1</td><td>ChengKai</td><td>HEB</td><td>1</td></tr><tr><td>1</td><td>ChenGuang</td><td>HEB</td><td>2</td></tr></tbody></table><p>我们现在想知道，访问各个省市的次数的详情，即访问一次,两次，三次的各有多少人。</p><p>可以使用分组函数 count 得到这些数据</p><p>分组数据展示：</p><table><thead><tr><th>province_code</th><th>visit_times</th><th>count</th></tr></thead><tbody><tr><td>BJ</td><td>0</td><td>2</td></tr><tr><td>BJ</td><td>1</td><td>1</td></tr><tr><td>SH</td><td>0</td><td>1</td></tr><tr><td>SH</td><td>1</td><td>1</td></tr><tr><td>SH</td><td>2</td><td>2</td></tr><tr><td>HEB</td><td>0</td><td>1</td></tr><tr><td>HEB</td><td>1</td><td>1</td></tr><tr><td>HEB</td><td>2</td><td>1</td></tr></tbody></table><p>但是，这样展示的话，数据不直观，我们想要得到下面这个样式的结果</p><table><thead><tr><th>visit_times</th><th>BJ</th><th>SH</th><th>HEB</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>2</td><td>1</td></tr></tbody></table><p>在 Oracle 数据库 11g 推出之前，您需要针对每个值通过 decode 函数进行以上操作，并将每个不同的值编写为一个单独的列。但是，该方法一点也不直观。</p><h3 id="Demo详解"><a href="#Demo详解" class="headerlink" title="Demo详解"></a>Demo详解</h3><p>本文中使用的数据，在文章最后，如果需要直接复制使用即可。</p><p>执行分组SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> province_code, times_purchased, <span class="keyword">count</span>(<span class="number">1</span>) cnt</span><br><span class="line"><span class="keyword">from</span> JOHANN_PIVOT_TEST</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> province_code, times_purchased</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> province_code;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><img src="/数据库/oracle/Oracle中的Pivot函数/jieguo3.png" title="分组函数结果"><p>执行包含有Pivot的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--注意：使用Pivot函数，你要知道自己需要哪些“列”，可通过上述的分组函数先找出来自己可能需要的“列”</span></span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> province_code, times_purchased </span><br><span class="line"> <span class="keyword">FROM</span> JOHANN_PIVOT_TEST</span><br><span class="line">)</span><br><span class="line"><span class="keyword">pivot</span> </span><br><span class="line">(</span><br><span class="line">   <span class="keyword">count</span>(province_code)</span><br><span class="line">   <span class="keyword">for</span> province_code <span class="keyword">in</span> (<span class="string">'BJ'</span>,<span class="string">'TJ'</span>,<span class="string">'HEB'</span>,<span class="string">'SH'</span>,<span class="string">'XZ'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> times_purchased;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><img src="/数据库/oracle/Oracle中的Pivot函数/jieguo2.png" title="Pivot函数结果"><p>如果想要以“访问次数”为列，则是需要把SQL做以下改动即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> province_code, times_purchased </span><br><span class="line"> <span class="keyword">FROM</span> JOHANN_PIVOT_TEST</span><br><span class="line">)</span><br><span class="line"><span class="keyword">pivot</span> </span><br><span class="line">(</span><br><span class="line">   <span class="keyword">count</span>(times_purchased)</span><br><span class="line">   <span class="keyword">for</span> times_purchased <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> province_code;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><img src="/数据库/oracle/Oracle中的Pivot函数/jieguo3.png" title="Pivot函数结果"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意:在pivot函数中，只允许使用分组函数</span><br><span class="line">Ø COUNT</span><br><span class="line">Ø AVG</span><br><span class="line">Ø SUM</span><br><span class="line">Ø MAX</span><br><span class="line">Ø MIN</span><br></pre></td></tr></table></figure><h3 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &quot;JOHANN_PIVOT_TEST&quot;;</span><br><span class="line">CREATE TABLE &quot;JOHANN_PIVOT_TEST&quot; (</span><br><span class="line">  &quot;CUST_ID&quot; NUMBER(10) NOT NULL ,</span><br><span class="line">  &quot;CUST_NAME&quot; VARCHAR2(20 BYTE) ,</span><br><span class="line">  &quot;PROVINCE_CODE&quot; VARCHAR2(3 BYTE) ,</span><br><span class="line">  &quot;TIMES_PURCHASED&quot; NUMBER(3) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT ALL </span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (1,&apos;temp&apos;,&apos;HEB&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (2,&apos;temp&apos;,&apos;HEB&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (3,&apos;temp&apos;,&apos;HEB&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (4,&apos;temp&apos;,&apos;HEB&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (5,&apos;temp&apos;,&apos;HEB&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (6,&apos;temp&apos;,&apos;HEB&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (7,&apos;temp&apos;,&apos;HEB&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (8,&apos;temp&apos;,&apos;HEB&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (9,&apos;temp&apos;,&apos;HEB&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (10,&apos;temp&apos;,&apos;HEB&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (11,&apos;temp&apos;,&apos;HEB&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (12,&apos;temp&apos;,&apos;HEB&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (13,&apos;temp&apos;,&apos;HEB&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (14,&apos;temp&apos;,&apos;HEB&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (15,&apos;temp&apos;,&apos;HEB&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (16,&apos;temp&apos;,&apos;HEB&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (17,&apos;temp&apos;,&apos;HEB&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (18,&apos;temp&apos;,&apos;HEB&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (19,&apos;temp&apos;,&apos;HEB&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (20,&apos;temp&apos;,&apos;HEB&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (21,&apos;temp&apos;,&apos;BJ&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (22,&apos;temp&apos;,&apos;BJ&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (23,&apos;temp&apos;,&apos;BJ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (24,&apos;temp&apos;,&apos;BJ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (25,&apos;temp&apos;,&apos;BJ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (26,&apos;temp&apos;,&apos;BJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (27,&apos;temp&apos;,&apos;BJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (28,&apos;temp&apos;,&apos;BJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (29,&apos;temp&apos;,&apos;BJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (30,&apos;temp&apos;,&apos;BJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (31,&apos;temp&apos;,&apos;BJ&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (32,&apos;temp&apos;,&apos;BJ&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (33,&apos;temp&apos;,&apos;BJ&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (34,&apos;temp&apos;,&apos;BJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (35,&apos;temp&apos;,&apos;BJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (36,&apos;temp&apos;,&apos;BJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (37,&apos;temp&apos;,&apos;BJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (38,&apos;temp&apos;,&apos;BJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (39,&apos;temp&apos;,&apos;TJ&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (40,&apos;temp&apos;,&apos;TJ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (41,&apos;temp&apos;,&apos;TJ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (42,&apos;temp&apos;,&apos;TJ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (43,&apos;temp&apos;,&apos;TJ&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (44,&apos;temp&apos;,&apos;TJ&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (45,&apos;temp&apos;,&apos;TJ&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (46,&apos;temp&apos;,&apos;TJ&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (47,&apos;temp&apos;,&apos;TJ&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (48,&apos;temp&apos;,&apos;TJ&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (49,&apos;temp&apos;,&apos;TJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (50,&apos;temp&apos;,&apos;TJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (51,&apos;temp&apos;,&apos;TJ&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (52,&apos;temp&apos;,&apos;SH&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (53,&apos;temp&apos;,&apos;SH&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (54,&apos;temp&apos;,&apos;SH&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (55,&apos;temp&apos;,&apos;SH&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (56,&apos;temp&apos;,&apos;SH&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (57,&apos;temp&apos;,&apos;SH&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (58,&apos;temp&apos;,&apos;SH&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (59,&apos;temp&apos;,&apos;SH&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (60,&apos;temp&apos;,&apos;SH&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (61,&apos;temp&apos;,&apos;SH&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (62,&apos;temp&apos;,&apos;SH&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (63,&apos;temp&apos;,&apos;SH&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (64,&apos;temp&apos;,&apos;SH&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (65,&apos;temp&apos;,&apos;SH&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (66,&apos;temp&apos;,&apos;SH&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (67,&apos;temp&apos;,&apos;SH&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (68,&apos;temp&apos;,&apos;SH&apos;,4)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (69,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (70,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (71,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (72,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (73,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (74,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (75,&apos;temp&apos;,&apos;SH&apos;,5)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (76,&apos;temp&apos;,&apos;XZ&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (77,&apos;temp&apos;,&apos;XZ&apos;,0)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (78,&apos;temp&apos;,&apos;XZ&apos;,1)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (79,&apos;temp&apos;,&apos;XZ&apos;,2)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (80,&apos;temp&apos;,&apos;XZ&apos;,3)</span><br><span class="line">INTO &quot;JOHANN_PIVOT_TEST&quot; (CUST_ID,CUST_NAME,PROVINCE_CODE,TIMES_PURCHASED) VALUES (81,&apos;temp&apos;,&apos;XZ&apos;,5)</span><br><span class="line">SELECT 1 FROM DUAL;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Pivot函数&quot;&gt;&lt;a href=&quot;#Pivot函数&quot; class=&quot;headerlink&quot; title=&quot;Pivot函数&quot;&gt;&lt;/a&gt;Pivot函数&lt;/h3&gt;&lt;p&gt;Pivot函数是在Oracle 数据库 11g 推出之后，新增的一个行数据转列数据的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://www.yhzhao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="oracle" scheme="https://www.yhzhao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/"/>
    
    
      <category term="java" scheme="https://www.yhzhao.com/tags/java/"/>
    
      <category term="数据库" scheme="https://www.yhzhao.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="oracle" scheme="https://www.yhzhao.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程入门</title>
    <link href="https://www.yhzhao.com/%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://www.yhzhao.com/线程/Java多线程入门/</id>
    <published>2019-09-12T02:17:23.000Z</published>
    <updated>2019-09-12T03:15:45.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><footer><strong>原文来源： SnailClimb</strong><cite><a href="https://juejin.im/post/5ab116875188255561411b8a#heading-25" target="_blank" rel="noopener">Java多线程入门</a></cite></footer></blockquote> <br><h3 id="进程和多线程简介"><a href="#进程和多线程简介" class="headerlink" title="进程和多线程简介"></a>进程和多线程简介</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><h5 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h5><p><font color="#FF0000">进程是程序的一次执行过程，是系统运行程序的基本单位</font>，因此进程是动态的。<font color="#FF0000">系统运行一个程序即是一个进程从创建，运行到消亡的过程</font>。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p><h5 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h5><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是<font color="#FF0000">同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多</font>，也正因为如此，线程也被称为<font color="#FF0000">轻量级进程</font>。</p><h5 id="线程和进程有何不同？"><a href="#线程和进程有何不同？" class="headerlink" title="线程和进程有何不同？"></a>线程和进程有何不同？</h5><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上<font color="#FF0000">各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响</font>。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><a id="more"></a><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="何为多线程？"><a href="#何为多线程？" class="headerlink" title="何为多线程？"></a>何为多线程？</h5><p>多线程就是<font color="#FF0000">几乎同时</font>执行多个线程（一个处理器在某一个时间点上永远都只能是一个线程！即使这个处理器是多核的，除非有多个处理器才能实现多个线程同时运行。）。<font color="#FF0000">几乎同时是因为实际上多线程程序中的多个线程实际上是一个线程执行一会然后其他的线程再执行</font>，并不是很多书籍所谓的同时执行。</p><h5 id="为什么多线程是必要的？"><a href="#为什么多线程是必要的？" class="headerlink" title="为什么多线程是必要的？"></a>为什么多线程是必要的？</h5><ol><li>使用线程可以把占据长时间的程序中的任务放到后台去处理</li><li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度</li><li>程序的运行速度可能加快</li></ol><h3 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.run();</span><br><span class="line">System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread mythread = <span class="keyword">new</span> MyThread();</span><br><span class="line">mythread.start();</span><br><span class="line">System.out.println(<span class="string">"运行结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/threadRun.png" title="继承Thread类"><p>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p><p>MyRunnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyRunnable"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Runnable runnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(<span class="string">"运行结束！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/runnableRun.png" title="实现Runnable接口"><h3 id="实例变量和线程安全"><a href="#实例变量和线程安全" class="headerlink" title="实例变量和线程安全"></a>实例变量和线程安全</h3><p>定义在线程类中的实例变量针对其他线程可以有共享和不共享之分</p><h4 id="不共享数据的情况"><a href="#不共享数据的情况" class="headerlink" title="不共享数据的情况"></a>不共享数据的情况</h4><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.run();</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(<span class="string">"由 "</span> + MyThread.currentThread().getName()</span><br><span class="line">+ <span class="string">" 计算，count="</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread a = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread b = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread c = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/threadbugongxiang.png" title="线程不共享数据"><p>可以看出每个线程都有一个属于自己的实例变量count，它们之间互不影响。我们再来看看另一种情况。</p><h4 id="共享数据的情况"><a href="#共享数据的情况" class="headerlink" title="共享数据的情况"></a>共享数据的情况</h4><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.run();</span><br><span class="line">count--;</span><br><span class="line">System.out.println(<span class="string">"由 "</span> + MyThread.currentThread().getName() + <span class="string">" 计算，count="</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyThread mythread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//下列线程都是通过mythread对象创建的</span></span><br><span class="line">Thread a=<span class="keyword">new</span> Thread(mythread,<span class="string">"A"</span>);</span><br><span class="line">Thread b=<span class="keyword">new</span> Thread(mythread,<span class="string">"B"</span>);</span><br><span class="line">Thread c=<span class="keyword">new</span> Thread(mythread,<span class="string">"C"</span>);</span><br><span class="line">Thread d=<span class="keyword">new</span> Thread(mythread,<span class="string">"D"</span>);</span><br><span class="line">Thread e=<span class="keyword">new</span> Thread(mythread,<span class="string">"E"</span>);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">d.start();</span><br><span class="line">e.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/threadgongxiang1.png" title="线程共享数据"><img src="/线程/Java多线程入门/threadgongxiang2.png" title="线程共享数据"><p>可以看出这里已经出现了错误</p><p>因为在大多数jvm中，count–的操作分为如下下三步：</p><p>1，取得原有count值</p><p>2，计算i -1</p><p>3，对i进行赋值</p><p>所以多个线程同时访问时出现问题就是难以避免的了。</p><p>那么有没有什么解决办法呢？</p><p>答案是：当然有，而且很简单。</p><p>在run方法前加上synchronized关键字即可得到正确答案。</p><h3 id="一些常用方法"><a href="#一些常用方法" class="headerlink" title="一些常用方法"></a>一些常用方法</h3><h4 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h4><p>返回对当前正在执行的线程对象的引用。</p><h4 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h4><p>返回此线程的标识符</p><h4 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h4><p>返回此线程的名称</p><h4 id="getPriority"><a href="#getPriority" class="headerlink" title="getPriority()"></a>getPriority()</h4><p>返回此线程的优先级</p><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h4><p>测试这个线程是否还处于活动状态。</p><p>什么是活动状态呢？</p><p>活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。</p><h4 id="sleep-long-millis"><a href="#sleep-long-millis" class="headerlink" title="sleep(long millis)"></a>sleep(long millis)</h4><p>使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p>中断这个线程。</p><h4 id="interrupted-和isInterrupted"><a href="#interrupted-和isInterrupted" class="headerlink" title="interrupted() 和isInterrupted()"></a>interrupted() 和isInterrupted()</h4><p>interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能。</p><p>isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志</p><h4 id="setName-String-name"><a href="#setName-String-name" class="headerlink" title="setName(String name)"></a>setName(String name)</h4><p>将此线程的名称更改为等于参数 name 。</p><h4 id="isDaemon"><a href="#isDaemon" class="headerlink" title="isDaemon()"></a>isDaemon()</h4><p>测试这个线程是否是守护线程。</p><h4 id="setDaemon-boolean-on"><a href="#setDaemon-boolean-on" class="headerlink" title="setDaemon(boolean on)"></a>setDaemon(boolean on)</h4><p>将此线程标记为 daemon线程或用户线程。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在很多情况下，主线程生成并启动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。</p><p>注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。</p><h4 id="setPriority-int-newPriority"><a href="#setPriority-int-newPriority" class="headerlink" title="setPriority(int newPriority)"></a>setPriority(int newPriority)</h4><p>更改此线程的优先级</p><h3 id="如何停止一个线程呢？"><a href="#如何停止一个线程呢？" class="headerlink" title="如何停止一个线程呢？"></a>如何停止一个线程呢？</h3><p>stop(),suspend(),resume()（仅用于与suspend()一起使用）这些方法已被弃用，所以我这里不予讲解。</p><img src="/线程/Java多线程入门/zuofei.png" title="已舍弃的方法"><h4 id="使用interrupt-方法"><a href="#使用interrupt-方法" class="headerlink" title="使用interrupt()方法"></a>使用interrupt()方法</h4><p>我们上面提到了interrupt()方法，先来试一下interrupt()方法能不能停止线程</p><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            System.out.println(<span class="string">"start"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"sleep"</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main catch"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/interruptNotStop.png" title="interrupt方法"><p>运行上诉代码你会发现，线程并不会终止。</p><p>针对上面代码的一个改进：</p><p>interrupted()方法判断线程是否停止，如果是停止状态则break</p><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.run();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (MyThread.interrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">"已经是停止状态了!我要退出了!"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"看到这句话说明线程并未终止------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            System.out.println(<span class="string">"start"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"sleep"</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main catch"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/breakNotStop.png" title="线程未停止"><p>for循环虽然停止执行了，但是for循环下面的语句还是会执行，说明线程并未被停止。</p><h4 id="使用return停止线程"><a href="#使用return停止线程" class="headerlink" title="使用return停止线程"></a>使用return停止线程</h4><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">"停止了!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"timer="</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">MyThread t=<span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/returnStop.png" title="线程停止"><p>线程终止。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这个==并不意味着低优先级的线程得不到运行，而只是它运行的几率比较小==，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p><p><font color="#FF0000">线程优先级具有继承特性比如A线程启动B线程，则B线程的优先级和A是一样的</font>。</p><p><font color="#FF0000">线程优先级具有随机性也就是说线程优先级高的不一定每一次都先执行完</font>。</p><p>Thread类中包含的成员变量代表了线程的某些优先级。如Thread.MIN_PRIORITY（常数1），Thread.NORM_PRIORITY（常数5）,<br>Thread.MAX_PRIORITY（常数10）。其中每个线程的优先级都在Thread.MIN_PRIORITY（常数1） 到Thread.MAX_PRIORITY（常数10） 之间，<font color="#FF0000">在默认情况下优先级都是Thread.NORM_PRIORITY（常数5）</font>。</p><p>线程优先级具有继承特性测试代码如下：</p><p>MyThread1.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyThread1 run priority="</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread2.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyThread2 run priority="</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"main thread begin priority="</span></span><br><span class="line">+ Thread.currentThread().getPriority());</span><br><span class="line">MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">thread1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/youxianji1.png" title="线程优先级继承性"><p>Run.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"main thread begin priority="</span></span><br><span class="line">+ Thread.currentThread().getPriority());</span><br><span class="line">Thread.currentThread().setPriority(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"main thread end   priority="</span></span><br><span class="line">+ Thread.currentThread().getPriority());</span><br><span class="line">MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">thread1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/youxianji2.png" title="线程优先级继承性"><h3 id="Java多线程分类"><a href="#Java多线程分类" class="headerlink" title="Java多线程分类"></a>Java多线程分类</h3><h4 id="多线程分类"><a href="#多线程分类" class="headerlink" title="多线程分类"></a>多线程分类</h4><h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 “佣人”。</p><p><font color="#FF0000">特点： 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</font></p><p>应用：数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</p><p><font color="#FF0000">最常见的守护线程：垃圾回收线程</font></p><h4 id="如何设置守护线程？"><a href="#如何设置守护线程？" class="headerlink" title="如何设置守护线程？"></a>如何设置守护线程？</h4><p>可以通过调用Thead类的setDaemon(true)方法设置当前的线程为守护线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常</span><br><span class="line">2. 在守护线程中产生的新线程也是守护线程</span><br><span class="line">3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</span><br></pre></td></tr></table></figure><p>MyThread.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">System.out.println(<span class="string">"i="</span> + (i));</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">"我离开thread对象也不再打印了，也就是停止了！"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/线程/Java多线程入门/shouhuThread.png" title="守护线程"><p>由运行结果可知，主线程结束后，守护线程也跟着结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;原文来源： SnailClimb&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://juejin.im/post/5ab116875188255561411b8a#heading-25&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java多线程入门&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; 
&lt;br&gt;

&lt;h3 id=&quot;进程和多线程简介&quot;&gt;&lt;a href=&quot;#进程和多线程简介&quot; class=&quot;headerlink&quot; title=&quot;进程和多线程简介&quot;&gt;&lt;/a&gt;进程和多线程简介&lt;/h3&gt;&lt;h4 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h4&gt;&lt;h5 id=&quot;何为进程？&quot;&gt;&lt;a href=&quot;#何为进程？&quot; class=&quot;headerlink&quot; title=&quot;何为进程？&quot;&gt;&lt;/a&gt;何为进程？&lt;/h5&gt;&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;进程是程序的一次执行过程，是系统运行程序的基本单位&lt;/font&gt;，因此进程是动态的。&lt;font color=&quot;#FF0000&quot;&gt;系统运行一个程序即是一个进程从创建，运行到消亡的过程&lt;/font&gt;。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。&lt;/p&gt;
&lt;h5 id=&quot;何为线程？&quot;&gt;&lt;a href=&quot;#何为线程？&quot; class=&quot;headerlink&quot; title=&quot;何为线程？&quot;&gt;&lt;/a&gt;何为线程？&lt;/h5&gt;&lt;p&gt;线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是&lt;font color=&quot;#FF0000&quot;&gt;同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多&lt;/font&gt;，也正因为如此，线程也被称为&lt;font color=&quot;#FF0000&quot;&gt;轻量级进程&lt;/font&gt;。&lt;/p&gt;
&lt;h5 id=&quot;线程和进程有何不同？&quot;&gt;&lt;a href=&quot;#线程和进程有何不同？&quot; class=&quot;headerlink&quot; title=&quot;线程和进程有何不同？&quot;&gt;&lt;/a&gt;线程和进程有何不同？&lt;/h5&gt;&lt;p&gt;线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上&lt;font color=&quot;#FF0000&quot;&gt;各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响&lt;/font&gt;。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。&lt;/p&gt;
    
    </summary>
    
      <category term="线程" scheme="https://www.yhzhao.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.yhzhao.com/tags/java/"/>
    
      <category term="多线程" scheme="https://www.yhzhao.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java集合详解</title>
    <link href="https://www.yhzhao.com/java/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.yhzhao.com/java/java集合详解/</id>
    <published>2019-08-09T07:42:52.000Z</published>
    <updated>2019-10-21T16:33:48.450Z</updated>
    
    <content type="html"><![CDATA[<p>集合类存放于java.util包下，主要有三种：Set（集），List（列表包含Queue），Map（映射）。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">差异点：</span><br><span class="line"></span><br><span class="line">Collections 这个类是集合的一个工具类（Arrays也是集合下的工具类），用于存放多个静态方法，供我们使用集合的时候直接调用。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="collection接口："><a href="#collection接口：" class="headerlink" title="collection接口："></a>collection接口：</h3><p> colletion是集合List，Set，Queqe的最基本的接口。<br> collection接口依赖Iterator接口</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p> List接口继承Collection接口</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>继承关系：</p><p>继承自AbstractList抽象类；实现List，RandomAccess（可随机访问），Cloneable，Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//添加新的元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><p>1，排列有序，可重复；</p><p>2，底层使用数组实现；</p><p>3，查询速度快，增删速度慢；</p><p>4，线程不安全；</p><p>5，当容量不足时，ArrayList是当前容量*1.5+1。Size为0的List的底层数组，在初始add元素的时候设置初始容量是10。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为什么线程不安全？</span><br><span class="line"></span><br><span class="line">查看源码，在add添加元素的时候，其实是分两步执行的</span><br><span class="line">    1，调用ensureCapacityInternal()方法，来判断当前的数组是否需要扩容</span><br><span class="line">    2，新增元素</span><br><span class="line">在多线程的程序中，多个线程同时操作某个数组，就可能会出现数组越界的情况。</span><br></pre></td></tr></table></figure><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>继承关系：</p><p>继承自AbstractList抽象类；实现List，RandomAccess（可随机访问），Cloneable，Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><p>1，排列有序，可重复；</p><p>2，底层使用数组实现；</p><p>3，查询速度快，增删速度慢；</p><p>4，线程安全，效率低；</p><p>5，当容量不足时，Vector是当前容量*2。Size为0的List的底层数组，在初始add元素的时候设置初始容量是10。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么Vector的线程是安全的？</span><br><span class="line"></span><br><span class="line">通过分析源码，我们看到Vector在add新元素的时候，也是分两步 1，判断是否需要扩容；2，新增元素。只不过，它所有add元素,remove元素的的方法上都有 synchronized 关键字</span><br></pre></td></tr></table></figure><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>继承关系：</p><p>继承自AbstractSequentialList抽象类；实现List，Deque（提供了操作队列的方法），Cloneable，Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><p>1，排列有序，可重复；</p><p>2，基于双向链表实现（JDK1.7/8 之后取消了循环，修改为双向链表）；</p><p>3，查询速度慢，增删快；</p><p>4，线程不安全。</p><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>Set继承Collection接口</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set 构造新的空链接哈希集</span></span><br><span class="line"><span class="comment"> * This package private constructor is only used by LinkedHashSet. 此包私有构造函数仅由LinkedHashSet使用</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系：</p><p>继承自AbstractSet抽象类；实现Set，Cloneable，Serializable接口</p><p>特征：</p><p>1，排列无序，不可重复（对象是否重复，是自己定义的，重写equals和hashCode方法）；</p><p>2，底层使用的是Hash表实现，内部是HashMap；</p><p>3，存储速度快；</p><p>4，一个 hashCode 位置上可以存放多个元素。</p><p>HashSet重写equals和hashcode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> HashSet重写equals和hashcode方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer code, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写equals方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> == o)&#123;<span class="comment">//是否与当前对象相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;<span class="comment">//是否与当前对象类相同</span></span><br><span class="line">            Student student = (Student) o;</span><br><span class="line">            <span class="keyword">if</span>((student.getCode()).equals(code))&#123;<span class="comment">//code相同，认定为是同一对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写hashcode方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (code==<span class="keyword">null</span>) ? <span class="number">0</span> :code.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">transient</span> <span class="title">NavigableMap</span>&lt;<span class="title">E</span>,<span class="title">Object</span>&gt; <span class="title">m</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系：</p><p>继承AbstractSet抽象类；实现NavigableSet，Cloneable，Serializable接口</p><p>特征：</p><p>1，底层使用二叉树实现，内部是TreeMap；</p><p>2，不可重复（对象是否重复，是自己定义的，重写equals和hashCode方法）；</p><p>3，排序存储；</p><p>4，需要保存的对象实现Comparable接口，重写compareTo方法；或者在对TreeSet进行实例化的时候，在构造函数中 通过匿名内部类 重写其中的compare方法。</p><p>TreeSet示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> TreeSetTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TreeSet排序测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1，TreeSet使用1 对象没有实现Comparable接口，需要在TreeSet的构造函数中新增匿名内部类Comparator，重新compare方法</span></span><br><span class="line">        Set&lt;Student&gt; studentSet = <span class="keyword">new</span> TreeSet&lt;Student&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.getCode() &gt; o2.getCode())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (o1.getCode() &lt; o2.getCode())&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        studentSet.add(<span class="keyword">new</span> Student(<span class="number">112</span>,<span class="string">"zyh112"</span>));</span><br><span class="line">        studentSet.add(<span class="keyword">new</span> Student(<span class="number">112</span>,<span class="string">"zyhcopy112"</span>));</span><br><span class="line">        studentSet.add(<span class="keyword">new</span> Student(<span class="number">111</span>,<span class="string">"zyh111"</span>));</span><br><span class="line">        studentSet.add(<span class="keyword">new</span> Student(<span class="number">113</span>,<span class="string">"zyh113"</span>));</span><br><span class="line">        System.out.println(studentSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2，TreeSet使用2 对象实现了Comparable接口，重写compareTo方法。无需在TreeSet的构造函数中新增匿名内部类</span></span><br><span class="line">        Set&lt;student2&gt; student2Set = <span class="keyword">new</span> TreeSet&lt;student2&gt;();</span><br><span class="line">        student2Set.add(<span class="keyword">new</span> student2(<span class="number">312</span>,<span class="string">"zyh312"</span>));</span><br><span class="line">        student2Set.add(<span class="keyword">new</span> student2(<span class="number">312</span>,<span class="string">"zyhcopy312"</span>));</span><br><span class="line">        student2Set.add(<span class="keyword">new</span> student2(<span class="number">311</span>,<span class="string">"zyh311"</span>));</span><br><span class="line">        student2Set.add(<span class="keyword">new</span> student2(<span class="number">313</span>,<span class="string">"zyh313"</span>));</span><br><span class="line">        System.out.println(student2Set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3， TreeSet不能使用实现Comparator接口的对象。报异常:student1 cannot be cast to java.lang.Comparable</span></span><br><span class="line">        Set&lt;student1&gt; student1Set = <span class="keyword">new</span> TreeSet&lt;student1&gt;();</span><br><span class="line">        student1Set.add(<span class="keyword">new</span> student1(<span class="number">212</span>,<span class="string">"zyh212"</span>));</span><br><span class="line">        student1Set.add(<span class="keyword">new</span> student1(<span class="number">212</span>,<span class="string">"zyhcpoy212"</span>));</span><br><span class="line">        student1Set.add(<span class="keyword">new</span> student1(<span class="number">211</span>,<span class="string">"zyh211"</span>));</span><br><span class="line">        student1Set.add(<span class="keyword">new</span> student1(<span class="number">213</span>,<span class="string">"zyh213"</span>));</span><br><span class="line">        System.out.println(student1Set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 待使用的普通对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer code, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写equals方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> == o)&#123;<span class="comment">//是否与当前对象相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;<span class="comment">//是否与当前对象类相同</span></span><br><span class="line">            Student student = (Student) o;</span><br><span class="line">            <span class="keyword">if</span>((student.getCode()).equals(code))&#123;<span class="comment">//code相同，认定为是同一对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写hashcode方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (code==<span class="keyword">null</span>) ? <span class="number">0</span> :code.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Comparator接口的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student1</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">student1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">student1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">student1</span><span class="params">(Integer code, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写equals方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> == o)&#123;<span class="comment">//是否与当前对象相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;<span class="comment">//是否与当前对象类相同</span></span><br><span class="line">            Student student = (Student) o;</span><br><span class="line">            <span class="keyword">if</span>((student.getCode()).equals(code))&#123;<span class="comment">//code相同，认定为是同一对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写hashcode方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (code==<span class="keyword">null</span>) ? <span class="number">0</span> :code.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写compare方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(student1 o1, student1 o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getCode() &gt; o2.getCode())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (o1.getCode() &lt; o2.getCode())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Comparable接口的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student2</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">student2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">student2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">student2</span><span class="params">(Integer code, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写equals方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> == o)&#123;<span class="comment">//是否与当前对象相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;<span class="comment">//是否与当前对象类相同</span></span><br><span class="line">            Student student = (Student) o;</span><br><span class="line">            <span class="keyword">if</span>((student.getCode()).equals(code))&#123;<span class="comment">//code相同，认定为是同一对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写hashcode方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (code==<span class="keyword">null</span>) ? <span class="number">0</span> :code.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 重写compareTo方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(student2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(code &gt; o.getCode())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (code &lt; o.getCode())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//return 0;</span></span><br><span class="line">            <span class="keyword">return</span> name.compareTo(o.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例运行结果：</p><img src="/java/java集合详解/treeSetException.png" title="treeSetException"><p>通过上述TreeSet示例，我们可以发现以下几点：</p><p>1，TreeSet需要保存的对象实现Comparable接口，重写compareTo方法，而不能保存实现Comparator接口的对象。</p><p>2，我们发现，即使student2重写了hashcode和equals方法，但是在TreeSet中，依然加入了重复元素。</p><p>为什么呢？</p><p>请注意student2类重写的compareTo方法：如果code相同，则继续比较name。在使用TreeSet的时候，要注意重写的compareTo方法是否与重写的hashcode，equals方法不一致。</p><p>//TODO<br>Comparator接口和Comparable接口对比差异？</p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedHashSet继承自HashSet，该方法即使HashSet中，LinkedHashSet的专用构造函数。</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set 构造新的空链哈希Set</span></span><br><span class="line"><span class="comment"> * This package private constructor is only used by LinkedHashSet. 此包私有构造函数仅由LinkedHashSet使用</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系：</p><p>继承自HashSet类；实现Set，Cloneable，Serializable接口</p><p>特征：</p><p>1，采用Hash表存储，不可重复。保证元素的唯一（哈希表），哈希表是真正存储数据的地方；</p><p>2，存储有序（底层有一个链接表），链表记录着存储数据的顺序（插入顺序）；</p><p>3，线程不安全，效率高；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">理解区分TreeSet和LinkedHashSet的“有序”</span><br><span class="line">1，TreeSet是根据重写的compareTo方法，对Set内部的集合进行排序，来实现Set“有序”。</span><br><span class="line">2，LinkedHashSet是根据内部链表记录插入顺序，来实现Set“有序”</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>循环，<span class="keyword">for</span> each，iterator循环合理使用</span><br><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列，与List和Set同级别，都继承自Collection接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1，什么是队列？</span><br><span class="line">队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。</span><br><span class="line"></span><br><span class="line">2，Queue的实现</span><br><span class="line">2.1，没有实现的阻塞接口的：</span><br><span class="line">    实现了java.util.Queue接口和java.util.AbstractQueue接口</span><br><span class="line">    内置的不阻塞队列： PriorityQueue 和 ConcurrentLinkedQueue</span><br><span class="line">    PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework 中加入两个具体集合实现。 </span><br><span class="line">2.1.1，PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。</span><br><span class="line">    加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。</span><br><span class="line">2.1.2，ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小，</span><br><span class="line">    ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。</span><br><span class="line"></span><br><span class="line">2.2，实现阻塞接口的：</span><br><span class="line">    java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，</span><br><span class="line">    线程执行操作阻塞，直到有空间或者元素可用。</span><br><span class="line">2.2.1，ArrayBlockingQueue ：一个由数组支持的有界队列。</span><br><span class="line">2.2.2，LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。</span><br><span class="line">2.2.3，PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。</span><br><span class="line">2.2.4，DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。</span><br><span class="line">2.2.5，SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</span><br><span class="line"></span><br><span class="line">3，总结：</span><br><span class="line">    当 Deque 当做 Queue队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素</span><br><span class="line">    Deque 也能当Stack栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。</span><br><span class="line">插一嘴：Stack过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用Deque来代替Stack进行栈操作。</span><br><span class="line">    ArrayDeque不是线程安全的。 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。</span><br></pre></td></tr></table></figure><p>使用阻塞队列实现一个生产者消费者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用阻塞队列实现一个生产者消费者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 定义装苹果的篮子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Basket</span></span>&#123;</span><br><span class="line">  <span class="comment">// 篮子，能够容纳3个苹果</span></span><br><span class="line">  BlockingQueue&lt;String&gt; basket = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产苹果，放入篮子</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">   <span class="comment">// put方法放入一个苹果，若basket满了，等到basket有位置</span></span><br><span class="line">   basket.put(<span class="string">"An apple"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 消费苹果，从篮子中取走</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">   <span class="comment">// get方法取出一个苹果，若basket为空，等到basket有苹果为止</span></span><br><span class="line">   String apple = basket.take();</span><br><span class="line">   <span class="keyword">return</span> apple;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAppleNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> basket.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//　测试方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBasket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 建立一个装苹果的篮子</span></span><br><span class="line">  <span class="keyword">final</span> Basket basket = <span class="keyword">new</span> Basket();</span><br><span class="line">  <span class="comment">// 定义苹果生产者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 生产苹果</span></span><br><span class="line">      System.out.println(<span class="string">"生产者准备生产苹果："</span> </span><br><span class="line">        + System.currentTimeMillis());</span><br><span class="line">      basket.produce();</span><br><span class="line">      System.out.println(<span class="string">"生产者生产苹果完毕："</span> </span><br><span class="line">        + System.currentTimeMillis());</span><br><span class="line">      System.out.println(<span class="string">"生产完后有苹果："</span>+basket.getAppleNumber()+<span class="string">"个"</span>);</span><br><span class="line">      <span class="comment">// 休眠300ms</span></span><br><span class="line">      Thread.sleep(<span class="number">300</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义苹果消费者</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 消费苹果</span></span><br><span class="line">      System.out.println(<span class="string">"消费者准备消费苹果："</span> </span><br><span class="line">        + System.currentTimeMillis());</span><br><span class="line">      basket.consume();</span><br><span class="line">      System.out.println(<span class="string">"消费者消费苹果完毕："</span> </span><br><span class="line">        + System.currentTimeMillis());</span><br><span class="line">      System.out.println(<span class="string">"消费完后有苹果："</span>+basket.getAppleNumber()+<span class="string">"个"</span>);</span><br><span class="line">      <span class="comment">// 休眠1000ms</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">  Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">  Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">  service.submit(producer);</span><br><span class="line">  service.submit(consumer);</span><br><span class="line">  <span class="comment">// 程序运行10s后，所有任务停止</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  service.shutdownNow();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BlockingQueueTest.testBasket();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>映射表的基础接口；依赖Collection接口</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>继承关系：</p><p>继承AbstractMap类；实现Map，Cloneable，Serializable接口</p><p>为什么HashMap的key允许为null ？？？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么HashMap的key允许为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的hashcode值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们可以看到，HashMap在计算hashcode值的时候，会判断Key是否为空，如果为空则将hashcode值置为 0</span></span><br><span class="line"><span class="comment"> * 所以HashMap的Key允许为空。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>HashMap内部实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内部实现：</span><br><span class="line">1，在JDK1.7中，HashMap的数据结构是，外层是一个数组，数组中每个元素是一个单项链表（Map.Entry）。</span><br><span class="line">    capacity：当前数组的容量，始终保持2^n，可以扩容，扩容后数组大小为当前的2倍。初始默认是 16 (1&gt;&gt;4)</span><br><span class="line">    loadFactor:负载因子，默认是 0.75f</span><br><span class="line">    threshold:扩容的阈值，等于capacity*loadFactor。即超过这个值，就会对数组进行扩容。</span><br><span class="line">    resize()方法，是一个十分消耗性能的方法，因为要重构hash表。</span><br><span class="line">2，在JDK1.8中，Hash的内部结构是由 数组+链表+红黑树 组成。在JDK7中，查找的时候，根据hash值我们可以快速定位到数组的具体下标，但是之后，</span><br><span class="line">需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度为O(n)。</span><br><span class="line">为了降低这部分的开销，在java1.8中，当链表中的元素达到 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候，可以降低时间复杂度为O(logN)。</span><br><span class="line">当外层数组index节点的元素个数减少 6 时，会把红黑数再转换为链表。</span><br></pre></td></tr></table></figure><p>//TODO<br>HashMap底层数据结构</p><p>特征：</p><p>1，Key不可重复（只允许存在一个null）,Value允许为null；</p><p>2，底层为数组+链表+红黑树（红黑树1.8新增）；</p><p>3，线程不安全，具有很快的访问速度。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>继承关系：</p><p>继承Dictionary类；实现Map，Cloneable，Serializable接口</p><p>为什么Hashtable的Key和Value都不允许为null ？？？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过以上源码我们可以看到，如果value为null，则抛出异常。计算key的hashcode值的时候，没有包装方法，</span></span><br><span class="line"><span class="comment"> * 而是直接使用的key.hashcode()方法，如果key为null，也会报空指针异常。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>特征：</p><p>1，hashtable是一个过时的类，不再推荐使用；</p><p>2，Key不允许为null，Value不允许为null；</p><p>3，继承自Dictionary类；</p><p>4，线程安全</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>继承关系：</p><p>继承AbstractMap类；实现NavigableMap，Cloneable，Serializable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果key为空，则直接抛出异常</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><p>1，Key不允许为null，Value允许为null；</p><p>2，TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序；</p><p>3，在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>继承关系：</p><p>继承HashMap类；实现Map接口</p><p>特征：</p><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>继承关系：</p><p>继承AbstractMap类；实现ConcurrentMap，Serializable接口</p><p>ConcurrentHashMap内部实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1，JDK1.5中的实现</span><br><span class="line">    ConcurrentHashMap使用的是分段锁技术,将ConcurrentHashMap将锁一段一段的存储，然后给每一段数据配一把锁（segment），</span><br><span class="line">    当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment。默认比Hashtable效率提高16倍。</span><br><span class="line"></span><br><span class="line">2，JDK1.8中的实现</span><br><span class="line">    ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</span><br><span class="line">    synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</span><br></pre></td></tr></table></figure><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查到内部正在移动元素（Node[] 数组扩容）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助它扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表或红黑二叉树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断f是否是链表的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果fh&gt;=0 是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表所有节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果节点存在，则更新value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//不存在则在链表尾部添加新节点。</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//TreeBin是红黑二叉树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//添加树节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                      value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前ConcurrentHashMap的size数量+1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><p>1，Key不允许为null，Value不允许为null；</p><p>2，线程安全，且效率比较高（锁分段技术）</p><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><p>//TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合类存放于java.util包下，主要有三种：Set（集），List（列表包含Queue），Map（映射）。&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;差异点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Collections 这个类是集合的一个工具类（Arrays也是集合下的工具类），用于存放多个静态方法，供我们使用集合的时候直接调用。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.yhzhao.com/categories/java/"/>
    
    
      <category term="java集合" scheme="https://www.yhzhao.com/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>单例模式探讨</title>
    <link href="https://www.yhzhao.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%8E%A2%E8%AE%A8/"/>
    <id>https://www.yhzhao.com/设计模式/单例模式探讨/</id>
    <published>2019-08-02T07:32:21.000Z</published>
    <updated>2019-10-21T16:47:27.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单的单例"><a href="#简单的单例" class="headerlink" title="简单的单例"></a>简单的单例</h3><p>这是一个简单的单例模式，如果我们在工作中，这么用的话，可能会存在一些问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//只能通过getInstance()方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我是简单的懒汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="懒汉式单例探讨"><a href="#懒汉式单例探讨" class="headerlink" title="懒汉式单例探讨"></a>懒汉式单例探讨</h3><h4 id="思考一"><a href="#思考一" class="headerlink" title="思考一"></a>思考一</h4><p>懒汉式单例是线程不安全的，如果我们在单线程中使用，是没有问题的。但是，如果是多线程的程序，这么用的话，就会产生一些麻烦。</p><p>如果两个线程同时进入if(instance == null)，都判断是null，那么此时就会得到两个实例，单例模式不再有意义。</p><p>为了保证多线程下懒汉式单例的线程安全，我们需要对实例化的方法加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加互斥锁的单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//只能通过getInstance()方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我是添加互斥锁的懒汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加完锁后，便可以保证了线程的安全。</p><h4 id="思考二"><a href="#思考二" class="headerlink" title="思考二"></a>思考二</h4><p>这样的单例实现，我们还是不太满意，因为每次调用getInstance()方法，都会加锁，影响程序的性能。而事实上，我们只需要在第一次调用该方法的时候，加锁就可以了。<br>即只要保证在调用 instance = new LazySingleton(); 的时候，加锁就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后添加互斥锁的单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//只能通过getInstance()方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123;&#125;&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我是修改后添加互斥锁的的懒汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即可以保证线程的安全，又解决了性能的问题。</p><p>但是，仍然存在问题。</p><h4 id="思考三"><a href="#思考三" class="headerlink" title="思考三"></a>思考三</h4><p>java平台内存模型中有一个叫“无序写”（out-of-order writes）的机制，当我们调用 instance = new LazySingleton(); 的时候，这一行其实做了两件事：<br>a.调用构造方法，创建了一个实例；b.把这个实例赋值给instance这个实例变量。而问题是，这两步JVM并不保证同时执行，即可能在调用构造函数之前，instance已经被设置为非空了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * "无序写"机制</span><br><span class="line"> *</span><br><span class="line"> *      这是jvm的特性，比如声明两个变量，String a; String b; jvm可能先加载a也可能先加载b。</span><br><span class="line"> *  同理，instance = new Singleton();可能在调用Singleton的构造函数之前就把instance置成了非空。</span><br><span class="line"> *  这是很多人会有疑问，说还没有实例化出Singleton的一个对象，那么instance怎么就变成非空了呢？</span><br><span class="line"> *  它的值现在是什么呢？想了解这个问题就要明白instance = new Singleton();这句话是怎么执行的，下面用一段伪代码向大家解释一下：</span><br><span class="line"> *  `</span><br><span class="line"> *  1, mem = allocate();             //为Singleton对象分配内存。</span><br><span class="line"> *  2, instance = mem;               //注意现在instance是非空的，但是还没有被初始化。</span><br><span class="line"> *  3, ctorSingleton(instance);    //调用Singleton的构造函数，传递instance.</span><br><span class="line"> *  </span><br><span class="line"> *  由此可见当一个线程执行到instance = mem; 时instance已为非空，如果此时另一个线程进入程序判断instance为非空，那么直接就跳转到return instance;</span><br><span class="line"> *  而此时Singleton的构造方法还未调用instance，现在的值为allocate();即返回的内存对象。</span><br><span class="line"> *  所以第二个线程得到的不是Singleton的一个对象，而是一个内存对象。</span><br><span class="line"> *</span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决无序写问题的单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//只能通过getInstance()方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123;&#125;&#123;</span><br><span class="line">                LazySingleton temp = instance;</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                    instance = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我是解决无序写问题的懒汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，便解决了懒汉式单例存在的一些问题。</p><h3 id="饿汉式单例探讨"><a href="#饿汉式单例探讨" class="headerlink" title="饿汉式单例探讨"></a>饿汉式单例探讨</h3><p>上面我们探讨了懒汉式单例模式，但到最后发现，这个单例有些臃肿，此时我们可以考虑饿汉式单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HungrySingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-7-10 15:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类在首次加载的时候，就创建好了一个实例对象，且之后不再改变，因此线程是安全的，可用于多线程。</span></span><br><span class="line"><span class="comment">     * 缺点：如果构造的单例很大，构造完又迟迟不使用，会导致资源浪费。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是饿汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，饿汉式单例是线程安全的，代码也更简洁些，但依旧存在问题。</p><h3 id="内部类实现懒汉式单例模式"><a href="#内部类实现懒汉式单例模式" class="headerlink" title="内部类实现懒汉式单例模式"></a>内部类实现懒汉式单例模式</h3><p>上面探讨的懒汉式单例和饿汉式单例都不太完美，我们在此引入一个内部类，来实现懒汉式单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> InnerClassLazySingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 内部类实现懒汉式单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-14 18:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassLazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span></span>&#123;</span><br><span class="line">        <span class="comment">//单例变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClassLazySingleton instance = <span class="keyword">new</span> InnerClassLazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**私有化的构造方法，保证外部的类不能通过构造器来实例化。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassLazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**获取单例对象实例*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassLazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是内部类实现的懒汉式单例！"</span>);</span><br><span class="line">        <span class="keyword">return</span> InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类实现懒汉式单例,避免上面的资源浪费、线程安全、代码简单。</p><p>因为java机制规定，内部类SingletonHolder只有在getInstance()方法第一次调用的时候才会被加载（实现了懒加载），</p><p>而且其加载过程是线程安全的（实现线程安全）。内部类加载的时候实例化一次instance。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单的单例&quot;&gt;&lt;a href=&quot;#简单的单例&quot; class=&quot;headerlink&quot; title=&quot;简单的单例&quot;&gt;&lt;/a&gt;简单的单例&lt;/h3&gt;&lt;p&gt;这是一个简单的单例模式，如果我们在工作中，这么用的话，可能会存在一些问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//简单的懒汉式单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LazySingleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LazySingleton instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有化构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LazySingleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//只能通过getInstance()方法获取实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LazySingleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LazySingleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;我是简单的懒汉式单例！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.yhzhao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="多线程" scheme="https://www.yhzhao.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://www.yhzhao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>变量,静态变量,代码块,静态块,构造函数的执行顺序</title>
    <link href="https://www.yhzhao.com/JVM/%E5%8F%98%E9%87%8F-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-%E4%BB%A3%E7%A0%81%E5%9D%97-%E9%9D%99%E6%80%81%E5%9D%97-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://www.yhzhao.com/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/</id>
    <published>2019-07-20T06:35:44.000Z</published>
    <updated>2019-10-21T16:47:18.775Z</updated>
    
    <content type="html"><![CDATA[<p>虽然之前了解到在类加载的时候，会先执行静态变量和静态代码块的声明，之后才是非静态代码块，且静态代码块仅执行一次。<br>但是，对这些内容总是觉得有些模糊，现对它们的执行顺序问题做一个总结，以供以后查阅。</p><a id="more"></a><p>PS:全局变量，成员变量，局部变量的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1，全局变量（全局静态变量）：</span><br><span class="line">       声明在类中，方法外，使用static修饰，作用于整个类；当类加载的时候，就被创建，全局唯一，跟随类的消失而消失；</span><br><span class="line">       存放方法区中。</span><br><span class="line">2，成员变量（实例变量，类的属性）:</span><br><span class="line">       声明在类中，方法外，作用与整个类中，被对象调用 ；new对象的时候存在，随着对象的消失而消失；</span><br><span class="line">       如果没有实例化那么变量是放在栈中；实例化了对象放在堆中，栈中放的是指向堆中对象的引用地址。</span><br><span class="line">3，局部变量： </span><br><span class="line">       声明在方法&#123; &#125;中，作用于这个方法&#123; &#125;中；方法被调用的时候创建，方法调用结束随之消失；</span><br><span class="line">       局部变量放在栈中，new的对象放在堆中，8中基本数据类型变量放在栈中，变量所对应的值是放在栈帧中。</span><br></pre></td></tr></table></figure><h3 id="变量-代码块-静态块-构造函数的执行顺序"><a href="#变量-代码块-静态块-构造函数的执行顺序" class="headerlink" title="变量,代码块,静态块,构造函数的执行顺序"></a>变量,代码块,静态块,构造函数的执行顺序</h3><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图1.1</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/11.png" title="图1.1"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由上图可知它们的执行顺序：静态块 &gt; 代码块 &gt; 构造函数。</span><br></pre></td></tr></table></figure><p><font color="#FF0000">静态块一定先于代码块执行吗？</font></p><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>在类里声明了静态对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图1.2</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/12.png" title="图1.2"><p>此时，发现先打印的代码块和构造函数，后打印的静态代码块。</p><p>上面的代码，使用到了final修饰，我们可以趁机使用“饿汉式单例模式”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">    <span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OuterClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out=OuterClass.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图1.3</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/13.png" title="图1.3"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过对边图1.2和图1.3的结果可知，静态代码块无论对象实例化几次，只执行一次。</span><br></pre></td></tr></table></figure><p>为什么会出现先打印的代码块和构造函数，后打印的静态代码块的情况呢？</p><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>将在类里声明的静态对象和静态块交换位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OuterClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out=OuterClass.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图1.4</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/14.png" title="图1.4"><p>将在类里声明了静态对象和静态块交换完位置，发现先打印的静态块，后打印的代码块和构造函数。</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/15.png" title="图1.5"><p>这是因为这个静态对象是个特殊的静态变量。如图1.5所示，静态变量和静态块的执行，是谁在前面，就先执行谁。在示例二中，先执行这个静态对象，而这个静态对象调用了实例化对象的方法，这个静态对象全部执行完后，才会执行下面的静态块。我们在使用饿汉式单例模式和静态块的时候，要注意这个问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态变量和静态块的执行，是谁在前面，就先执行谁</span><br><span class="line">在使用饿汉式单例模式和静态块的时候，要注意静态对象和静态块的顺序问题。</span><br></pre></td></tr></table></figure><h3 id="内部类，外部类的执行顺序"><a href="#内部类，外部类的执行顺序" class="headerlink" title="内部类，外部类的执行顺序"></a>内部类，外部类的执行顺序</h3><h4 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h4><p>包含内部类的执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OuterClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 静态内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:40 2019-07-20</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类的构造函数。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的代码块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 非静态内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:48 2019-07-20</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类的构造函数 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类中的代码块 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类中的方法 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//OuterClass out = new OuterClass();</span></span><br><span class="line">        OuterClass out=OuterClass.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态内部类实例化格式： OutClass.StaticInner staticInner = new OutClass.StaticInner();</span></span><br><span class="line">        OuterClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OuterClass.StaticInnerClass();</span><br><span class="line">        staticInnerClass.innerMethod();</span><br><span class="line">        OuterClass.StaticInnerClass.innerStaticMethod();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态内部类实例化格式： OutClass.InnerClass innerClass = outClassInstance.new InnerClass();</span></span><br><span class="line">        OuterClass.InnerClass innerClass = out.new InnerClass();</span><br><span class="line">        innerClass.innerMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图2.1</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/21.png" title="图2.1"><p>由于我们先初始化的外部类，后实例化的内部类。即先外后内，然后按照各自的静态块&gt;代码块&gt;构造函数执行下来的。</p><h4 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h4><p>现修改程序为如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OuterClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 静态内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:40 2019-07-20</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类的构造函数。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的代码块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 非静态内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:48 2019-07-20</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类的构造函数 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类中的代码块 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"非静态内部类中的方法 #####"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//OuterClass out = new OuterClass();</span></span><br><span class="line">        <span class="comment">//OuterClass out=OuterClass.getInstance();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态内部类实例化格式： OutClass.StaticInner staticInner = new OutClass.StaticInner();</span></span><br><span class="line">        OuterClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OuterClass.StaticInnerClass();</span><br><span class="line">        staticInnerClass.innerMethod();</span><br><span class="line">        OuterClass.StaticInnerClass.innerStaticMethod();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态内部类实例化格式： OutClass.InnerClass innerClass = outClassInstance.new InnerClass();</span></span><br><span class="line">        <span class="comment">//OuterClass.InnerClass innerClass = out.new InnerClass();</span></span><br><span class="line">        <span class="comment">//innerClass.innerMethod();</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图2.2所示</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/22.png" title="图2.2"><p>我们已经注掉初始化外部类的代码了，但是出来的结果和示例一是一样的。</p><p>这是因为：我们执行的main函数，存在于这个外部类中，所以即使我们没有明写，这个外部类也一样初始化了，且先于内部类。</p><h4 id="示例三-1"><a href="#示例三-1" class="headerlink" title="示例三"></a>示例三</h4><p>不再在外部类中调用main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OuterClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 类加载过程中的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 11:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OuterClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的构造函数====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的静态块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类中的代码块====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 静态内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 14:40 2019-07-20</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类的构造函数。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的代码块。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的静态方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类中的方法。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> TestClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Johann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-07-20 13:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态内部类实例化格式： OutClass.StaticInner staticInner = new OutClass.StaticInner();</span></span><br><span class="line">        OuterClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OuterClass.StaticInnerClass();</span><br><span class="line">        staticInnerClass.innerMethod();</span><br><span class="line">        OuterClass.StaticInnerClass.innerStaticMethod();</span><br><span class="line"></span><br><span class="line">        OuterClass out=OuterClass.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加载完成 。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图2.3</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/23.png" title="图2.3"><p>内部类的执行顺序先于外部类</p><p>在我们注释掉 OuterClass out=OuterClass.getInstance(); 这段代码的时候，运行结果如图2.4</p><img src="/JVM/变量-静态变量-代码块-静态块-构造函数的执行顺序/24.png" title="图2.4"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果调用的方法在外部类中，那么外部类永远先于内部类执行；</span><br><span class="line">如果是在其他类类中调用，则看他们初始化的顺序。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然之前了解到在类加载的时候，会先执行静态变量和静态代码块的声明，之后才是非静态代码块，且静态代码块仅执行一次。&lt;br&gt;但是，对这些内容总是觉得有些模糊，现对它们的执行顺序问题做一个总结，以供以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.yhzhao.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.yhzhao.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章搞定nvm，node.js，npm，nrm安装</title>
    <link href="https://www.yhzhao.com/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/nvm-node-js-npm-nrm/"/>
    <id>https://www.yhzhao.com/环境配置/nvm-node-js-npm-nrm/</id>
    <published>2019-03-10T06:31:44.000Z</published>
    <updated>2019-10-10T06:52:21.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="nvm，node-js，npm，nrm的关系"><a href="#nvm，node-js，npm，nrm的关系" class="headerlink" title="nvm，node.js，npm，nrm的关系"></a>nvm，node.js，npm，nrm的关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1, nvm ： nvm是node.js的版本管理工具，用于管理node.js和npm的版本。</span><br><span class="line">2, node.js ： node.js是javascript的一种运行环境，是对Google V8引擎进行的封装，是一个服务器端的javascript的解释器。</span><br><span class="line">3, npm ： npm是随同node.js一起安装的包管理工具，npm管理对应nodeJs的第三方插件。</span><br><span class="line">4, nrm ： nrm是npm registry管理工具，可以用来管理npm的镜像源。</span><br></pre></td></tr></table></figure> <a id="more"></a><img src="/环境配置/nvm-node-js-npm-nrm/guanxitu.png" title="nvm，node.js，npm关系图"><h4 id="为什么要用nvm来管理node版本"><a href="#为什么要用nvm来管理node版本" class="headerlink" title="为什么要用nvm来管理node版本"></a>为什么要用nvm来管理node版本</h4><p>在开发中，有时候对node的版本有要求，有时候需要切换到指定的node版本来重现问题等。遇到这种需求的时候，我们需要能够灵活的切换node版本。</p><h4 id="nrm有什么用"><a href="#nrm有什么用" class="headerlink" title="nrm有什么用"></a>nrm有什么用</h4><p>当我们使用npm来下载所需要的包时，可能由于网络的原因，需要等待很长时间才能完成下载，使用nrm切换npm镜像源为taobao，可以快速下载完成。</p><img src="/环境配置/nvm-node-js-npm-nrm/nrmyongchu.png" title="nrm管理npm镜像源"><hr><h3 id="Windows下nvm的下载安装"><a href="#Windows下nvm的下载安装" class="headerlink" title="Windows下nvm的下载安装"></a>Windows下nvm的下载安装</h3><p>由于官方版本并不支持Windows，所以需要 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm-windows</a>来实现Windows下的 nvm 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载之前，请确保已卸载所有的Node.js</span><br></pre></td></tr></table></figure> <p><a href="https://github.com/coreybutler/nvm-windows/wiki" target="_blank" rel="noopener">说明文档</a></p><h4 id="下载免安装包"><a href="#下载免安装包" class="headerlink" title="下载免安装包"></a>下载免安装包</h4><img src="/环境配置/nvm-node-js-npm-nrm/nvmxiazai.png" title="nvm下载地址"><p>解压完成后，有如下几个文件</p><img src="/环境配置/nvm-node-js-npm-nrm/nvmjieya.png" title="nvm解压"><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>解压完成后，还需要设置以下环境变量</p><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>NVM_HOME</td><td>E:\softWare\nvm</td></tr><tr><td>NVM_SYMLINK</td><td>E:\softWare\nodejs</td></tr><tr><td>Path</td><td>%NVM_HOME%</td></tr><tr><td>Path</td><td>%NVM_SYMLINK%</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVM_HOME ： nvm的解压路径</span><br><span class="line">NVM_SYMLINK ： 路径用于标识使用的哪个版本的node.js</span><br></pre></td></tr></table></figure> <img src="/环境配置/nvm-node-js-npm-nrm/hjbl.png" title="nvm环境变量"><h4 id="新建-settings-txt"><a href="#新建-settings-txt" class="headerlink" title="新建 settings.txt"></a>新建 settings.txt</h4><p>在解压目录下，新建 settings.txt 文件，文件包含以下属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root ： 存储不同版本node.js的路径，同 NVM_HOME;</span><br><span class="line">path ： 当前使用的node.js的路径，同NVM_SYMLINK；</span><br><span class="line">proxy ： 一般设置为 &quot;none&quot;。如果需要使用代理，可以使用命令行中的nvm对其进行修改。</span><br><span class="line">arch ： 标识操作系统，32或64</span><br></pre></td></tr></table></figure><img src="/环境配置/nvm-node-js-npm-nrm/setting.png" title="setting.txt示例"><h4 id="nvm安装完成"><a href="#nvm安装完成" class="headerlink" title="nvm安装完成"></a>nvm安装完成</h4><p>使用 nvm 命令验证，是否安装成功。</p><img src="/环境配置/nvm-node-js-npm-nrm/nvmcmd.png" title="nvm验证"><hr><h3 id="使用-nvm-安装node-js"><a href="#使用-nvm-安装node-js" class="headerlink" title="使用 nvm 安装node.js"></a>使用 nvm 安装node.js</h3><h4 id="切换nvm镜像源"><a href="#切换nvm镜像源" class="headerlink" title="切换nvm镜像源"></a>切换nvm镜像源</h4><p>nvm默认的下载地址是 <a href="http://nodejs.org/dist/" target="_blank" rel="noopener">nvm默认镜像源</a> ，国内访问的话会很慢。<br>所以在使用nvm安装node之前，建议切换镜像源。</p><p>切换nvm镜像源的方法很简单，只需要把下面两行，复制到上面的 settings.txt 文件中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><img src="/环境配置/nvm-node-js-npm-nrm/nvmjingxiang.png" title="nvm镜像源"><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用命令:</span><br><span class="line">nvm list available #查看远程所有可用的node版本</span><br><span class="line">nvm list #查看本地所有node版本</span><br><span class="line">nvm install 8.11.2 #安装 8.11.2 版本</span><br><span class="line">nvm use 8.11.2 #切换至 8.11.2 版本</span><br><span class="line">nvm uninstall 8.11.2 #卸载8.11.2 版本</span><br></pre></td></tr></table></figure><p>选择一个版本下载，下载 node.js 的同时，会把npm也一同下载下来。</p><p>下载完成后，通过 node -v 和 npm -v 命令，查询当前的版本。</p><img src="/环境配置/nvm-node-js-npm-nrm/node_npm.png" title="node，npm版本"><hr><h3 id="nrm-–-NPM-registry-manager"><a href="#nrm-–-NPM-registry-manager" class="headerlink" title="nrm – NPM registry manager"></a>nrm – NPM registry manager</h3><p>当使用 npm 下载第三方插件的时候，默认使用的镜像源会请求国外服务器，国内访问的话，会比较慢，通过使用 nrm ，可以在不同的 npm 镜像源之间快速切换。</p><h4 id="安装nrm"><a href="#安装nrm" class="headerlink" title="安装nrm"></a>安装nrm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><h4 id="nrm的使用"><a href="#nrm的使用" class="headerlink" title="nrm的使用"></a>nrm的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 nrm -ls 命令，可以查看所有可切换的 npm 镜像源。其中，带 * 的为当前正在使用的 npm 镜像源。</span><br><span class="line"></span><br><span class="line">执行 nrm use &lt;name&gt; 命令，用于切换 npm 镜像源。</span><br></pre></td></tr></table></figure><img src="/环境配置/nvm-node-js-npm-nrm/npmjingxiang.png" title="nrm管理npm镜像源"><p>切换完成后，之后再使用 npm install 下载第三方插件时，都会从新的镜像源地址进行下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h3&gt;&lt;h4 id=&quot;nvm，node-js，npm，nrm的关系&quot;&gt;&lt;a href=&quot;#nvm，node-js，npm，nrm的关系&quot; class=&quot;headerlink&quot; title=&quot;nvm，node.js，npm，nrm的关系&quot;&gt;&lt;/a&gt;nvm，node.js，npm，nrm的关系&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1, nvm ： nvm是node.js的版本管理工具，用于管理node.js和npm的版本。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2, node.js ： node.js是javascript的一种运行环境，是对Google V8引擎进行的封装，是一个服务器端的javascript的解释器。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3, npm ： npm是随同node.js一起安装的包管理工具，npm管理对应nodeJs的第三方插件。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4, nrm ： nrm是npm registry管理工具，可以用来管理npm的镜像源。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://www.yhzhao.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Node" scheme="https://www.yhzhao.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Mysql下载安装</title>
    <link href="https://www.yhzhao.com/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Mysql%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
    <id>https://www.yhzhao.com/环境配置/Mysql下载安装/</id>
    <published>2019-03-10T03:22:50.000Z</published>
    <updated>2019-09-03T07:45:57.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址: <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网下载</a> </p><p>下载合适的Mysql压缩包，本文为例，下载的版本是 “mysql-5.7.27-winx64.zip”</p><a id="more"></a><img src="/环境配置/Mysql下载安装/xiazaidizhi.png" title="下载地址"><p>下载完成后，将zip包解压到相应的目录下，本文解压目录是  “E:\softWare\mysql\mysql-5.7.27-winx64”</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>打开解压目录，在该目录下创建 名为 my.ini 的配置文件</p><img src="/环境配置/Mysql下载安装/wenjiandizhi.png" title="my.ini"><p>文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=E:\\softWare\\mysql\\mysql-5.7.27-winx64</span><br><span class="line"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span><br><span class="line">datadir=E:\\softWare\\mysql\\sqldata</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><p>注意：文件分割符使用的是转义字符 “\\“</p><img src="/环境配置/Mysql下载安装/peizhiwenjian.png" title="my.ini"><p>以管理员身份打开cmd，切换目录至 ${mysql_home}\bin 目录下，执行下述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">切换至此目录下：</span><br><span class="line">E:\softWare\mysql\mysql-5.7.27-winx64\bin&gt;</span><br><span class="line"></span><br><span class="line">执行命令：</span><br><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure><p>执行成功后，会提示生成初始密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此密码用于后续登录mysql时使用。</p><p>再执行以下安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure><p>初始化data目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>启动mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>至此mysql安装成功。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><img src="/环境配置/Mysql下载安装/cmd1.png" title="命令不识别"><p>我们每次在启动mysql 的时候，都需要先切换到 ${mysql_home}\bin 目录下，才会识别mysql命令。要使得每次打开cmd，都可以识别mysql命令，需要配置以下环境变量。</p><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>Path</td><td>E:\softWare\mysql\mysql-5.7.27-winx64\bin</td></tr></tbody></table><p>配置完成后，识别mysql命令</p><img src="/环境配置/Mysql下载安装/cmd2.png" title="命令识别"><h3 id="登录Mysql，修改密码"><a href="#登录Mysql，修改密码" class="headerlink" title="登录Mysql，修改密码"></a>登录Mysql，修改密码</h3><p>输入以下命令，登录mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br><span class="line"></span><br><span class="line">-h 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;</span><br><span class="line"></span><br><span class="line">-u  登录的用户名;</span><br><span class="line"></span><br><span class="line">-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</span><br></pre></td></tr></table></figure><p>然后输入上面默认生成的密码，即可登录mysql.</p><p>登陆成功后，可以使用以下命令，修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for root@localhost = password(&apos;新密码&apos;);</span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="由于找不到MSVCR120-dll-无法继续执行代码-重新安装程序可能会解决此问题"><a href="#由于找不到MSVCR120-dll-无法继续执行代码-重新安装程序可能会解决此问题" class="headerlink" title="由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题"></a>由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题</h4><img src="/环境配置/Mysql下载安装/cuowu.png" title="找不到MSVCR120.dll"><p>解决办法：这是由于缺少文件 vcredist ，<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=40784" target="_blank" rel="noopener">下载</a>安装这个文件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;下载地址: &lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网下载&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;下载合适的Mysql压缩包，本文为例，下载的版本是 “mysql-5.7.27-winx64.zip”&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://www.yhzhao.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mysql" scheme="https://www.yhzhao.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat安装，配置</title>
    <link href="https://www.yhzhao.com/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Tomcat%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.yhzhao.com/环境配置/Tomcat安装，配置/</id>
    <published>2019-03-10T02:35:41.000Z</published>
    <updated>2019-09-03T03:39:43.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>下载地址： <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">官方下载</a></p><p>下载合适的压缩包，下载完成对其解压，即可完成安装。</p><a id="more"></a><img src="/环境配置/Tomcat安装，配置/xiazaidizhi.png" title="下载地址"><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>CATALINA_BASE</td><td>E:\softWare\tomcat\apache-tomcat-8.5.43</td></tr><tr><td>CATALINA_HOME</td><td>E:\softWare\tomcat\apache-tomcat-8.5.43</td></tr><tr><td>Path</td><td>%CATALINA_HOME%\lib</td></tr><tr><td>Path</td><td>%CATALINA_HOME%\bin</td></tr></tbody></table><img src="/环境配置/Tomcat安装，配置/hjbl1.png" title="环境变量"><img src="/环境配置/Tomcat安装，配置/hjbl2.png" title="环境变量"><h3 id="启动-关闭-tomcat"><a href="#启动-关闭-tomcat" class="headerlink" title="启动/关闭 tomcat"></a>启动/关闭 tomcat</h3><h4 id="启动方式1"><a href="#启动方式1" class="headerlink" title="启动方式1"></a>启动方式1</h4><p>进入安装目录下的bin目录，双击 startup.bat 即可完成启动。</p><img src="/环境配置/Tomcat安装，配置/qd1.png" title="启动方式"><p>启动成功后，访问 localhost:8080</p><img src="/环境配置/Tomcat安装，配置/qd2.png" title="访问tomcat"><h4 id="启动方式2"><a href="#启动方式2" class="headerlink" title="启动方式2"></a>启动方式2</h4><p>进入命令行，输入 startup 命令  [startup.bat命令 也可以]，即可启动 tomcat。</p><h4 id="关闭方式1"><a href="#关闭方式1" class="headerlink" title="关闭方式1"></a>关闭方式1</h4><p>进入bin目录下，双击 shutdown.bat 即可关闭 tomcat。</p><p>进入命令行，输入 shutdown.bat ，也可以关闭 tomcat。Windows下，如果输入的命令是 shutdown , 则会和windows本身的shutdown命令冲突。</p><img src="/环境配置/Tomcat安装，配置/gb.png" title="命令冲突"><h3 id="启动乱码的问题"><a href="#启动乱码的问题" class="headerlink" title="启动乱码的问题"></a>启动乱码的问题</h3><p>在启动tomcat的过程中，控制台有乱码的情况出现：</p><img src="/环境配置/Tomcat安装，配置/luanma1.png" title="启动乱码"><p>解决办法：修改 E:\softWare\tomcat\apache-tomcat-8.5.43\conf 下的 logging.properties 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br><span class="line">改为</span><br><span class="line">java.util.logging.ConsoleHandler.encoding = GBK</span><br></pre></td></tr></table></figure><img src="/环境配置/Tomcat安装，配置/luanma2.png" title="修改配置"><p>修改完成后，启动不再乱码</p><img src="/环境配置/Tomcat安装，配置/luanma3.png" title="启动不再乱码">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h3&gt;&lt;p&gt;下载地址： &lt;a href=&quot;https://tomcat.apache.org/download-80.cgi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载合适的压缩包，下载完成对其解压，即可完成安装。&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://www.yhzhao.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="java" scheme="https://www.yhzhao.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>maven安装，配置</title>
    <link href="https://www.yhzhao.com/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/maven%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.yhzhao.com/环境配置/maven安装，配置/</id>
    <published>2019-03-10T02:05:12.000Z</published>
    <updated>2019-09-03T02:55:20.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>下载地址：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网下载</a></p><p>下载完成后，解压到指定的文件夹，即可完成安装。</p><a id="more"></a><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>MAVEN_HOME</td><td>E:\softWare\maven\apache-maven-3.6.1</td></tr><tr><td>Path</td><td>%MAVEN_HOME%\bin</td></tr><tr><td>MAVEN_OPTS [可选配置]</td><td>-Xms128m -Xmx512m</td></tr></tbody></table><img src="/环境配置/maven安装，配置/hjbl2.png" title="环境变量"><img src="/环境配置/maven安装，配置/hjbl1.png" title="环境变量"><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>运行命令 mvn -v</p><p>输入内容，则说明安装成功。</p><img src="/环境配置/maven安装，配置/banbenyanzheng.png" title="安装验证"><h3 id="可选配置"><a href="#可选配置" class="headerlink" title="可选配置"></a>可选配置</h3><h4 id="1，修改maven本地仓库"><a href="#1，修改maven本地仓库" class="headerlink" title="1，修改maven本地仓库"></a>1，修改maven本地仓库</h4><p>如果没用改动，使用maven的过程中，下载的jar包，默认的保存路径是 “${user.home}/.m2/repository”。我们可以通过，修改配置文件，指定下载路径。</p><p>跳转到maven安装路径下，修改conf文件夹下的 settings.xml 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;E:\softWare\maven\repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><img src="/环境配置/maven安装，配置/bendiku.png" title="maven本地库修改"><p>修改完成后，之后的所有jar包将下载到此路径下。</p><h4 id="2，修改maven远程仓库"><a href="#2，修改maven远程仓库" class="headerlink" title="2，修改maven远程仓库"></a>2，修改maven远程仓库</h4><p>还是修改安装目录下的settings.xml文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;  </span><br><span class="line">     &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">     &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><img src="/环境配置/maven安装，配置/yuanchengku.png" title="maven远程仓库修改">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h3&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完成后，解压到指定的文件夹，即可完成安装。&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://www.yhzhao.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="maven" scheme="https://www.yhzhao.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Java安装及环境配置</title>
    <link href="https://www.yhzhao.com/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Java%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.yhzhao.com/环境配置/Java安装及环境配置/</id>
    <published>2019-03-10T01:14:23.000Z</published>
    <updated>2019-09-02T02:06:27.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>使用以下网址，下载指定的JDK。</p><p>下载地址1：<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官方下载</a></p><p>下载地址2： <a href="https://pan.baidu.com/s/1vFoMuAYVQRgMeImJWe_rfg" target="_blank" rel="noopener">jdk-8u221-windows-x64</a> 提取码[xrj9]</p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>打开已下载的JDK，“下一步next”到底，中间可自定义自己的安装路径。</p><img src="/环境配置/Java安装及环境配置/anzhuanglujing.png" title="安装路径"><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="完成环境变量的配置，需要添加以下几组环境变量。"><a href="#完成环境变量的配置，需要添加以下几组环境变量。" class="headerlink" title="完成环境变量的配置，需要添加以下几组环境变量。"></a>完成环境变量的配置，需要添加以下几组环境变量。</h4><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>E:\softWare\java\jdk</td></tr><tr><td>CLASSPATH</td><td>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;</td></tr><tr><td>Path</td><td>%JAVA_HOME%\bin</td></tr></tbody></table><img src="/环境配置/Java安装及环境配置/hjbl1.png" title="环境变量配置"><img src="/环境配置/Java安装及环境配置/hjbl2.png" title="环境变量配置"><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>打开CMD，输入 java -version 或 javac -version</p><img src="/环境配置/Java安装及环境配置/cmd.png" title="安装验证"><p>若有输出，则证明安装成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h3&gt;&lt;h4 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h4&gt;&lt;p&gt;使用以下网址，下载指定的JDK。&lt;/p&gt;
&lt;p&gt;下载地址1：&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址2： &lt;a href=&quot;https://pan.baidu.com/s/1vFoMuAYVQRgMeImJWe_rfg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jdk-8u221-windows-x64&lt;/a&gt; 提取码[xrj9]&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://www.yhzhao.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="java" scheme="https://www.yhzhao.com/tags/java/"/>
    
  </entry>
  
</feed>
